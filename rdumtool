#!/usr/bin/env python3

# rdumtool
# Copyright (C) 2019 Ryan Finnie
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

import argparse
import struct
import sys
import os
import json
import time
import datetime
import logging

__version__ = '1.0'


class DeviceBluetooth:
    def __init__(self, mac=None):
        import bluetooth
        self.bluetooth = bluetooth

        if mac is not None:
            self.connect(mac)

    def scan(self):
        return self.bluetooth.discover_devices(duration=8, lookup_names=True, lookup_class=True)

    def connect(self, mac):
        self.dev = self.bluetooth.BluetoothSocket(self.bluetooth.RFCOMM)
        self.dev.connect((mac, 1))

    def send(self, data):
        logging.debug('SEND: {}'.format(repr(data)))
        self.dev.send(data)

    def recv(self):
        data = b''
        while(len(data) < 130):
            data += self.dev.recv(1024)
        logging.debug('RECV: {}'.format(repr(data)))
        return data


class DeviceSerial:
    def __init__(self, fn):
        import serial

        self.dev = serial.Serial()
        self.dev.port = fn
        self.dev.baudrate = 9600
        self.dev.parity = 'N'
        self.dev.writeTimeout = 0
        self.dev.open()

    def send(self, data):
        self.dev.write(data)

    def recv(self):
        data = b''
        while(len(data) < 130):
            data += self.dev.read()
        return data


class DataGroup:
    group = 0
    amp_hours = 0
    watt_hours = 0

    def __init__(self, group=0):
        self.group = group


class Response:
    CHARGING_UNKNOWN = 0
    CHARGING_QC2 = 1
    CHARGING_QC3 = 2
    CHARGING_APP2_4A = 3
    CHARGING_APP2_1A = 4
    CHARGING_APP1_0A = 5
    CHARGING_APP0_5A = 6
    CHARGING_DCP1_5A = 7
    CHARGING_SAMSUNG = 8

    def __init__(self, data=None, collection_time=None, device_type='UM24C'):
        self.device_type = device_type
        if device_type == 'UM25C':
            self.device_multiplier = 10
        else:
            self.device_multiplier = 1
        self._std_defs = {
            'volts': ('Volts', 2, 2, lambda x: x / (100 * self.device_multiplier)),
            'amps': ('Amps', 4, 2, lambda x: x / (1000 * self.device_multiplier)),
            'watts': ('Watts', 6, 4, lambda x: x / 1000),
            'temp_c': ('Temperature (Celsius)', 10, 2, lambda x: x),
            'temp_f': ('Temperature (Fahrenheit)', 12, 2, lambda x: x),
            'data_group_selected': ('Currently selected data group', 14, 2, lambda x: x),
            'data_line_positive_volts': ('Positive data line volts', 96, 2, lambda x: x / 100),
            'data_line_negative_volts': ('Negative data line volts', 98, 2, lambda x: x / 100),
            'charging_mode': ('Charging mode', 100, 2, lambda x: x),
            'record_amphours': ('Recorded amp-hours', 102, 4, lambda x: x / 1000),
            'record_watthours': ('Recorded watt-hours', 106, 4, lambda x: x / 1000),
            'record_threshold': ('Recording threshold (Amps)', 110, 2, lambda x: x / 100),
            'record_seconds': ('Recorded time (Seconds)', 112, 4, lambda x: x),
            'recording': ('Recording', 116, 2, lambda x: bool(x)),
            'screen_timeout': ('Screen timeout (Minutes)', 118, 2, lambda x: x),
            'screen_brightness': ('Screen brightness', 120, 2, lambda x: x),
            'resistance': ('Resistance (Ohms)', 122, 4, lambda x: x / 10),
            'screen_selected': ('Currently selected screen', 126, 2, lambda x: x),
        }

        self.collection_time = collection_time
        for name in self._std_defs:
            setattr(self, name, 0)
        self.data_groups = [DataGroup(x) for x in range(10)]
        self.labels = {x: self._std_defs[x][0] for x in self._std_defs}
        self.labels['data_groups'] = 'Data groups'
        self.labels['collection_time'] = 'Collection time'

        if data:
            self.parse_binary(data)

    def parse_binary(self, data):
        # Disabled for now.  Supposedly UM34C is 0d4c, 8068.
        # No idea what UM25C is.
        # if data[0:2] != b'\x09\x63' or data[-2:] != b'\xff\xf1':
        #     raise ValueError('Invalid start/stop markers', data)
        for name in self._std_defs:
            pos = self._std_defs[name][1]
            pos_len = self._std_defs[name][2]
            if pos_len == 2:
                pack_format = '>H'
            elif pos_len == 4:
                pack_format = '>L'
            else:
                pack_format = 'B'
            conversion = self._std_defs[name][3]
            val = conversion(struct.unpack(pack_format, data[pos:pos+pos_len])[0])
            setattr(self, name, val)

        self.data_groups = []
        for i in range(10):
            data_group = DataGroup(i)
            pos = 16 + (i * 8)
            data_group.amp_hours = struct.unpack('>L', data[pos:pos+4])[0] / 1000
            data_group.watt_hours = struct.unpack('>L', data[pos+4:pos+8])[0] / 1000
            self.data_groups.append(data_group)


def parse_args(argv=None):
    """Parse user arguments."""
    if argv is None:
        argv = sys.argv

    parser = argparse.ArgumentParser(
        description='rdumtool ({})'.format(__version__),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        prog=os.path.basename(argv[0]),
    )

    parser.add_argument(
        '--version', '-V', action='version',
        version=__version__,
        help='Report the program version',
    )

    parser.add_argument(
        '--quiet', '-q', action='store_true',
        help='Whether to display human-readable information to stderr',
    )
    parser.add_argument(
        '--debug', action='store_true',
        help='Print extra debugging information.',
    )
    parser.add_argument(
        '--device-type', '-t', choices=['UM24C', 'UM25C', 'UM34C'], default='UM24C',
        help='Device type',
    )
    device_group = parser.add_mutually_exclusive_group(required=False)
    device_group.add_argument(
        '--bluetooth-device', '-d',
        help='Bluetooth MAC address of the device',
    )
    device_group.add_argument(
        '--serial-device', '-s',
        help='Serial filename (e.g. /dev/rfcomm0) of the device',
    )
    parser.add_argument(
        '--json', action='store_true',
        help='Output JSON data',
    )
    parser.add_argument(
        '--watch', type=float, const=2.0, nargs='?', default=None,
        help='Repeat every WATCH seconds',
    )
    parser.add_argument(
        '--next-screen', action='store_true',
        help='Go to the next screen on the display',
    )
    parser.add_argument(
        '--previous-screen', action='store_true',
        help='[UM25C, UM34C] Go to the previous screen on the display',
    )
    parser.add_argument(
        '--rotate-screen', action='store_true',
        help='Rotate the screen 90 degrees clockwise',
    )
    parser.add_argument(
        '--set-data-group', type=int, choices=range(10), default=None,
        help='[UM25C, UM34C] Set the selected data group',
    )
    parser.add_argument(
        '--next-data-group', action='store_true',
        help='[UM24C] Change to the next data group',
    )
    parser.add_argument(
        '--clear-data-group', action='store_true',
        help='Clear the current data group',
    )
    parser.add_argument(
        '--set-record-threshold', type=float, choices=[x / 100 for x in range(31)], default=None,
        help='Set the recording threshold',
    )
    parser.add_argument(
        '--set-screen-brightness', type=int, choices=range(6), default=None,
        help='Set the screen brightness',
    )
    parser.add_argument(
        '--set-screen-timeout', type=int, choices=range(10), default=None,
        help='Set the screen timeout',
    )

    args = parser.parse_args(args=argv[1:])
    return args


class RDUMTool:
    def print_json(self, response):
        out = {x: getattr(response, x) for x in response.labels}
        out['data_groups'] = [{'amp_hours': x.amp_hours, 'watt_hours': x.watt_hours} for x in out['data_groups']]
        out['collection_time'] = (out['collection_time'] - datetime.datetime.fromtimestamp(0)).total_seconds()
        print(json.dumps(out))

    def print_human(self, response):
        charging_map = {
            response.CHARGING_UNKNOWN: 'Unknown / Normal',
            response.CHARGING_QC2: 'Quick Charge 2.0',
            response.CHARGING_QC3: 'Quick Charge 3.0',
            response.CHARGING_APP2_4A: 'Apple 2.4A',
            response.CHARGING_APP2_1A: 'Apple 2.1A',
            response.CHARGING_APP1_0A: 'Apple 1.0A',
            response.CHARGING_APP0_5A: 'Apple 0.5A',
            response.CHARGING_DCP1_5A: 'DCP 1.5A',
            response.CHARGING_SAMSUNG: 'Samsung',
        }
        print('USB: {:5.02f}V, {:6.03f}A, {:6.03f}W, {:6.01f}Î©'.format(
            response.volts,
            response.amps,
            response.watts,
            response.resistance,
        ))
        print('Data: {:5.02f}V(+), {:5.02f}V(-), charging mode: {}'.format(
            response.data_line_positive_volts,
            response.data_line_negative_volts,
            charging_map[response.charging_mode],
        ))
        print('Recording {:5}: {:8.03f}Ah, {:8.03f}Wh, {:6d} sec at >= {:4.02f}A'.format(
            '(on)' if response.recording else '(off)',
            response.record_amphours,
            response.record_watthours,
            response.record_seconds,
            response.record_threshold,
        ))

        def make_dgpart(response, idx):
            data_group = response.data_groups[idx]
            return '{}{:d}: {:8.03f}Ah, {:8.03f}Wh'.format(
                '*' if data_group.group == response.data_group_selected else ' ',
                data_group.group,
                data_group.amp_hours,
                data_group.watt_hours,
            )
        print('Data groups:')
        print('    {:32}{}'.format(
          make_dgpart(response, 0),
          make_dgpart(response, 5),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 1),
          make_dgpart(response, 6),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 2),
          make_dgpart(response, 7),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 3),
          make_dgpart(response, 8),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 4),
          make_dgpart(response, 9),
        ))

        print('{:>5s}, temperature: {:3d}C ({:3d}F)'.format(self.args.device_type, response.temp_c, response.temp_f))
        print('Screen: {:d}/6, brightness: {:d}/5, timeout: {}'.format(
            response.screen_selected,
            response.screen_brightness,
            '{:d} min'.format(response.screen_timeout) if response.screen_timeout else 'off',
        ))
        if response.collection_time:
            print('Collection time: {}'.format(response.collection_time))

    def send_commands(self):
        # TODO: Verify UM25C/UM34C
        for arg, command_val, compat in [
            ('next_screen', b'\xf1', ['UM24C', 'UM25C', 'UM34C']),
            ('rotate_screen', b'\xf2', ['UM24C', 'UM25C', 'UM34C']),
            ('next_data_group', b'\xf3', ['UM24C']),
            ('previous_screen', b'\xf3', ['UM25C', 'UM34C']),
            ('clear_data_group', b'\xf4', ['UM24C', 'UM25C', 'UM34C']),
            ('set_data_group', lambda x: bytes([0xa0 + x]), ['UM25C', 'UM34C']),
            ('set_record_threshold', lambda x: bytes([0xb0 + int(x * 100)]), ['UM24C', 'UM25C', 'UM34C']),
            ('set_screen_brightness', lambda x: bytes([0xd0 + x]), ['UM24C', 'UM25C', 'UM34C']),
            ('set_screen_timeout', lambda x: bytes([0xe0 + x]), ['UM24C', 'UM25C', 'UM34C']),
        ]:
            arg_val = getattr(self.args, arg)
            if (arg_val is None) or (arg_val is False):
                continue
            if self.args.device_type not in compat:
                logging.warning('{} not supported on this device, ignoring'.format(arg))
                continue
            if type(command_val) != bytes:
                command_val = command_val(getattr(self.args, arg))
            logging.info('Setting {} to {}'.format(arg, getattr(self.args, arg)))
            self.dev.send(command_val)
            # Sometimes you can send multiple commands quickly, but sometimes
            # it'll eat commands.  Sleeping 0.5s between commands is safe.
            time.sleep(0.5)

    def main(self):
        self.args = parse_args()

        # Logging setup
        logging_format='%(message)s'
        if self.args.debug:
            logging_level = logging.DEBUG
            logging_format='%(asctime)s %(levelname)s: %(message)s'
        elif self.args.quiet:
            logging_level = logging.ERROR
        else:
            logging_level = logging.INFO
        logging.basicConfig(
            format=logging_format,
            level=logging_level,
        )

        logging.info('rdumtool {}'.format(__version__))
        logging.info('Copyright (C) 2019 Ryan Finnie')
        logging.info('')

        if (not self.args.bluetooth_device) and (not self.args.serial_device):
            logging.info('Searching for Bluetooth devices, please wait')
            self.dev = DeviceBluetooth()
            for mac, name, bt_class in self.dev.scan():
                logging.info('    {} - {}'.format(mac, name))
                if name in ('UM24C', 'UM25C', 'UM34C'):
                    self.args.bluetooth_device = mac
                    self.args.device_type = name
            if not self.args.bluetooth_device:
                logging.error('No suitable Bluetooth device found')
                return
        if self.args.bluetooth_device:
            logging.info('Connecting to {} {}'.format(self.args.device_type, self.args.bluetooth_device))
            self.dev = DeviceBluetooth(self.args.bluetooth_device)
        elif self.args.serial_device:
            logging.info('Connecting to {} {}'.format(self.args.device_type, self.args.serial_device))
            self.dev = DeviceSerial(self.args.serial_device)
        logging.info('Connection established')
        logging.info('')

        self.send_commands()

        while True:
            try:
                self.dev.send(b'\xf0')
                if self.args.json:
                    self.print_json(Response(
                        self.dev.recv(),
                        collection_time=datetime.datetime.now(),
                        device_type=self.args.device_type,
                    ))
                else:
                    self.print_human(Response(
                        self.dev.recv(),
                        collection_time=datetime.datetime.now(),
                        device_type=self.args.device_type,
                    ))
            except KeyboardInterrupt:
                return
            except:
                logging.exception('An exception has occurred')
                if not self.args.watch:
                    return 1
            if self.args.watch:
                if not self.args.json:
                    print()
                try:
                    time.sleep(self.args.watch)
                except KeyboardInterrupt:
                    return
            else:
                break


if __name__ == '__main__':
    sys.exit(RDUMTool().main())
