#!/usr/bin/env python3

# rdumtool
# Copyright (C) 2019 Ryan Finnie
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

import argparse
import struct
import sys
import os
import json
import time
import datetime
import traceback

__version__ = '1.0'


class DeviceBluetooth:
    def __init__(self, mac):
        import bluetooth

        self.dev = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
        self.dev.connect((mac, 1))

    def send(self, data):
        self.dev.send(data)

    def recv(self):
        data = b''
        while(len(data) < 130):
            data += self.dev.recv(1024)
        return data


class DeviceSerial:
    def __init__(self, fn):
        import serial

        self.dev = serial.Serial()
        self.dev.port = fn
        self.dev.baudrate = 9600
        self.dev.parity = 'N'
        self.dev.writeTimeout = 0
        self.dev.open()

    def send(self, data):
        self.dev.write(data)

    def recv(self):
        data = b''
        while(len(data) < 130):
            data += self.dev.read()
        return data


class DataGroup:
    group = 0
    amp_hours = 0
    watt_hours = 0

    def __init__(self, group=0):
        self.group = group


class Response:
    CHARGING_UNKNOWN = 0
    CHARGING_QC2 = 1
    CHARGING_QC3 = 2

    _std_defs = {
        'volts': ('Volts', 2, 2, lambda x: x / 100),
        'amps': ('Amps', 4, 2, lambda x: x / 1000),
        'watts': ('Watts', 6, 4, lambda x: x / 1000),
        'temp_c': ('Temperature (Celsius)', 10, 2, lambda x: x),
        'temp_f': ('Temperature (Fahrenheit)', 12, 2, lambda x: x),
        'data_group_selected': ('Currently selected data group', 14, 2, lambda x: x),
        'data_line_positive_volts': ('Positive data line volts', 96, 2, lambda x: x / 100),
        'data_line_negative_volts': ('Negative data line volts', 98, 2, lambda x: x / 100),
        'charging_mode': ('Charging mode', 100, 2, lambda x: x),
        'record_amphours': ('Recorded amp-hours', 102, 4, lambda x: x / 1000),
        'record_watthours': ('Recorded watt-hours', 106, 4, lambda x: x / 1000),
        'record_threshold': ('Recording threshold (Amps)', 110, 2, lambda x: x / 100),
        'record_seconds': ('Recorded time (Seconds)', 112, 4, lambda x: x),
        'recording': ('Recording', 116, 2, lambda x: bool(x)),
        'screen_timeout': ('Screen timeout (Minutes)', 118, 2, lambda x: x),
        'screen_brightness': ('Screen brightness', 120, 2, lambda x: x),
        'resistance': ('Resistance (Ohms)', 122, 4, lambda x: x / 10),
        'screen_selected': ('Currently selected screen', 126, 2, lambda x: x),
    }

    def __init__(self, data=None, collection_time=None):
        self.collection_time = collection_time
        for name in self._std_defs:
            setattr(self, name, 0)
        self.data_groups = [DataGroup(x) for x in range(10)]
        self.labels = {x: self._std_defs[x][0] for x in self._std_defs}
        self.labels['data_groups'] = 'Data groups'
        self.labels['collection_time'] = 'Collection time'

        if data:
            self.parse_binary(data)

    def parse_binary(self, data):
        if data[0:2] != b'\x09\x63' or data[-2:] != b'\xff\xf1':
            raise ValueError('Invalid start/stop markers', data)
        for name in self._std_defs:
            pos = self._std_defs[name][1]
            pos_len = self._std_defs[name][2]
            if pos_len == 2:
                pack_format = '>H'
            elif pos_len == 4:
                pack_format = '>L'
            else:
                pack_format = 'B'
            conversion = self._std_defs[name][3]
            val = conversion(struct.unpack(pack_format, data[pos:pos+pos_len])[0])
            setattr(self, name, val)

        self.data_groups = []
        for i in range(10):
            data_group = DataGroup(i)
            pos = 16 + (i * 8)
            data_group.amp_hours = struct.unpack('>L', data[pos:pos+4])[0] / 1000
            data_group.watt_hours = struct.unpack('>L', data[pos+4:pos+8])[0] / 1000
            self.data_groups.append(data_group)


def parse_args(argv=None):
    """Parse user arguments."""
    if argv is None:
        argv = sys.argv

    parser = argparse.ArgumentParser(
        description='rdumtool ({})'.format(__version__),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        prog=os.path.basename(argv[0]),
    )

    parser.add_argument(
        '--version', '-V', action='version',
        version=__version__,
        help='report the program version',
    )

    device_group = parser.add_mutually_exclusive_group(required=True)
    device_group.add_argument(
        '--bluetooth-device', '-d',
        help='Bluetooth MAC address of the UM24C',
    )
    device_group.add_argument(
        '--serial-device', '-s',
        help='Serial filename (e.g. /dev/rfcomm0) of the UM24C',
    )
    parser.add_argument(
        '--json', action='store_true',
        help='Output JSON data',
    )
    parser.add_argument(
        '--watch', type=float, const=2.0, nargs='?', default=None,
        help='Repeat every WATCH seconds',
    )
    parser.add_argument(
        '--next-screen', action='store_true',
        help='Go to the next screen on the display',
    )
    parser.add_argument(
        '--rotate-screen', action='store_true',
        help='Rotate the screen 90 degrees clockwise',
    )
    parser.add_argument(
        '--next-data-group', action='store_true',
        help='Change to the next data group',
    )
    parser.add_argument(
        '--clear-data-group', action='store_true',
        help='Clear the current data group',
    )
    parser.add_argument(
        '--set-record-threshold', type=float, choices=[x / 100 for x in range(31)], default=None,
        help='Set the recording threshold (0.00-0.30 amps, inclusive)',
    )
    parser.add_argument(
        '--set-screen-brightness', type=int, choices=range(6), default=None,
        help='Set the screen brightness (0-5, inclusive)',
    )
    parser.add_argument(
        '--set-screen-timeout', type=int, choices=range(10), default=None,
        help='Set the screen timeout (0-9 minutes, inclusive)',
    )

    args = parser.parse_args(args=argv[1:])
    return args


class RDUMTool:
    def print_json(self, response):
        out = {x: getattr(response, x) for x in response.labels}
        out['data_groups'] = [{'amp_hours': x.amp_hours, 'watt_hours': x.watt_hours} for x in out['data_groups']]
        out['collection_time'] = (out['collection_time'] - datetime.datetime.fromtimestamp(0)).total_seconds()
        print(json.dumps(out))

    def print_human(self, response):
        charging_map = {
            response.CHARGING_UNKNOWN: 'unknown (normal)',
            response.CHARGING_QC2: 'Quick Charge 2.0',
            response.CHARGING_QC3: 'Quick Charge 3.0',
        }
        print('USB: {:5.02f}V, {:6.03f}A, {:6.03f}W, {:6.01f}Î©'.format(
            response.volts,
            response.amps,
            response.watts,
            response.resistance
        ))
        print('Data: {:5.02f}V(+), {:5.02f}V(-), charging mode: {}'.format(
            response.data_line_positive_volts,
            response.data_line_negative_volts,
            charging_map[response.charging_mode]
        ))
        print('Recording {:5}: {:8.03f}Ah, {:8.03f}Wh, {:4d} sec at >= {:4.02f}A'.format(
            '(on)' if response.recording else '(off)',
            response.record_amphours,
            response.record_watthours,
            response.record_seconds,
            response.record_threshold,
        ))

        def make_dgpart(response, idx):
            data_group = response.data_groups[idx]
            return '{}{:d}: {:8.03f}Ah, {:8.03f}Wh'.format(
                '*' if data_group.group == response.data_group_selected else ' ',
                data_group.group,
                data_group.amp_hours,
                data_group.watt_hours,
            )
        print('Data groups:')
        print('    {:32}{}'.format(
          make_dgpart(response, 0),
          make_dgpart(response, 5),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 1),
          make_dgpart(response, 6),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 2),
          make_dgpart(response, 7),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 3),
          make_dgpart(response, 8),
        ))
        print('    {:32}{}'.format(
          make_dgpart(response, 4),
          make_dgpart(response, 9),
        ))

        print('Temperature: {:3d}C ({:3d}F)'.format(response.temp_c, response.temp_f))
        print('Screen: {:d}/6, brightness: {:d}/5, timeout: {}'.format(
            response.screen_selected,
            response.screen_brightness,
            '{:d} min'.format(response.screen_timeout) if response.screen_timeout else 'off',
        ))
        if response.collection_time:
            print('Collection time: {}'.format(response.collection_time))

    def send_commands(self):
        commands = b''
        for arg, command_val in {
            'next_screen': b'\xf1',
            'rotate_screen': b'\xf2',
            'next_data_group': b'\xf3',
            'clear_data_group': b'\xf4',
            'set_record_threshold': lambda x: bytes([0xb0 + int(x * 100)]),
            'set_screen_brightness': lambda x: bytes([0xd0 + x]),
            'set_screen_timeout': lambda x: bytes([0xe0 + x]),
        }.items():
            arg_val = getattr(self.args, arg)
            if (arg_val is None) or (arg_val is False):
                continue
            print('{} {}'.format(arg, getattr(self.args, arg)))
            if type(command_val) != bytes:
                command_val = command_val(getattr(self.args, arg))
            commands += command_val
        if commands:
            self.dev.send(commands)
            return True
        else:
            return False

    def main(self):
        self.args = parse_args()

        if self.args.bluetooth_device:
            self.dev = DeviceBluetooth(self.args.bluetooth_device)
        else:
            self.dev = DeviceSerial(self.args.serial_device)

        if self.send_commands() is True:
            return

        if not self.args.json:
            print('rdumtool {}'.format(__version__))
            print('Copyright (C) 2019 Ryan Finnie')
            print()
        while True:
            try:
                self.dev.send(b'\xf0')
                if self.args.json:
                    self.print_json(Response(self.dev.recv(), collection_time=datetime.datetime.now()))
                else:
                    self.print_human(Response(self.dev.recv(), collection_time=datetime.datetime.now()))
            except KeyboardInterrupt:
                return
            except:
                traceback.print_exc()
                if not self.args.watch:
                    return 1
            if self.args.watch:
                if not self.args.json:
                    print()
                try:
                    time.sleep(self.args.watch)
                except KeyboardInterrupt:
                    return
            else:
                break


if __name__ == '__main__':
    sys.exit(RDUMTool().main())
